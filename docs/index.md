# How does iterum work

I will not dive into technical details about each of the phases.
Instead, I give you an overall structure of each phase, starting from the first one and to the last one.

## Token

[sources](../src/token)

> A lexical token or simply token is a string with an assigned and thus identified meaning.
> It is structured as a pair consisting of a token name and an optional token value.
> The token name is a category of lexical unit.

Here, in iterum, I hold the following data in tokens:

- Token Name
- Lexeme
- Location of lexeme

Each time, scanner analyzes the whole word, it creates a token structure with required information.

Example:

```javascript
let a = 20;
```

```text
<Token, keyword, let, 1:3>
<Token, identifier, a, 1:5>
<Token, operator, =, 1:7>
<Token, number, 20, 1:11>
<Token, operator, ;, 1:12>
```

## Scanner

[sources](../src/scanner)

> In computer science, lexical analysis, tokenization or scanning is the process of converting a sequence of characters (such as in a computer program or web page) into a sequence of tokens (strings with an assigned and thus identified meaning).
> A program that performs lexical analysis may be termed a lexer, tokenizer, or scanner, though scanner is also a term for the first stage of a lexer.
> A lexer is generally combined with a parser, which together analyze the syntax of programming languages, web pages, and so forth.

Nothing special in this one.
I'm going through source code and analyze it char by char, returning `Token` instances (described above), that will be fed to the parser in the next phase.

## Parser

[sources](../src/parser)

> A parser is a software component that takes input data (frequently text) and builds a data structure â€“ often some kind of parse tree, abstract syntax tree or other hierarchical structure, giving a structural representation of the input while checking for correct syntax.
> The parsing may be preceded or followed by other steps, or these may be combined into a single step.
> The parser is often preceded by a separate lexical analyser, which creates tokens from the sequence of input characters; alternatively, these can be combined in scanner-less parsing.
> Parsers may be programmed by hand or may be automatically or semi-automatically generated by a parser generator.
> Parsing is complementary to templating, which produces formatted output.
> These may be applied to different domains, but often appear together, such as the scanf/printf pair, or the input (front end parsing) and output (back end code generation) stages of a compiler.

iterum has a recursive descent approach:

> In computer science, a recursive descent parser is a kind of top-down parser built from a set of mutually recursive procedures (or a non-recursive equivalent) where each such procedure implements one of the non-terminals of the grammar.
> Thus the structure of the resulting program closely mirrors that of the grammar it recognizes.

The result of the parser is an ESTree.

## AST

[sources](../src/ast)

> In computer science, an abstract syntax tree (AST), or just syntax tree, is a tree representation of the abstract syntactic structure of source code written in a programming language.
> Each node of the tree denotes a construct occurring in the source code.
> The syntax is "abstract" in the sense that it does not represent every detail appearing in the real syntax, but rather just the structural, content-related details.
> For instance, grouping parentheses are implicit in the tree structure, and a syntactic construct like an if-condition-then expression may be denoted by means of a single node with three branches.

AST in iterum is implemented as a bunch of interfaces.
These interfaces were derived from [ESTree specification](https://github.com/estree/estree).

Every time I need to create an AST node, I was just creating an object with an explicit casting to required interface.

i.e.

```javascript
function openNode() {
    return { ...content_here } as IIdentifier;
}
```

## Traverser

[sources](../src/traverser)

> In computer science, tree traversal (also known as tree search) is a form of graph traversal and refers to the process of visiting (checking and/or updating) each node in a tree data structure, exactly once.
> Such traversals are classified by the order in which the nodes are visited.
> The following algorithms are described for a binary tree, but they may be generalized to other trees as well.

iterum uses traverser for passing the control to specified callbacks, based on type of nodes it traverses.

## Interpreter

[sources](../src/interpreter)

> In computer science, an interpreter is a computer program that directly executes instructions written in a programming or scripting language, without requiring them previously to have been compiled into a machine language program.
> An interpreter generally uses one of the following strategies for program execution:
> Parse the source code and perform its behavior directly;
> Translate source code into some efficient intermediate representation and immediately execute this;
> Explicitly execute stored pre-compiled code made by a compiler which is part of the interpreter system;

In case with iterum, I went with "Translate source code into some efficient intermediate representation and immediately execute this" approach.

When parsing was done, the result of the parser is an AST.
You can look at it as it is an intermediate representation of your code.

This AST is passed directly to interpreter, that starts traversing the tree and execute command directly from it.

## Symbols

[sources](../src/symbols)

> In computer science, a symbol table is a data structure used by a language translator such as a compiler or interpreter, where each identifier (a.k.a. symbol) in a program's source code is associated with information relating to its declaration or appearance in the source.
> In other words, the entries of a symbol table stores the information related to the entry's corresponding symbol.

Since, iterum implements dynamic programming language, all we need to store in symbol table is a name of identifer and the actual value it holds (class, string, function, etc).

So, symbol table in iterum is a simple `Map<string, Value>`, where key is a name of variable that holds some runtime `Value`.

## Runtime

[sources](../src/runtime)

Runtime in iterum is responsible for providing features like functions, classes, primitive types, etc...

It has an abstract class, called `Value`, that has all the basic operations for casting AST nodes into internal iterum representation, that actually can do useful things.

When interpreter goes through AST nodes, it creates appropriate instances of `Value`-s from runtime and stores it on the heap.

## Errors

[sources](../src/errors)

Nothing to say.
Just a simple classes wrapped around native Error.

## CLI

[sources](../src/cli)

> A command-line interface is a means of interacting with a computer program where the user (or client) issues commands to the program in the form of successive lines of text (command lines).
> A program which handles the interface is called a command language interpreter or shell.

Nothing special here, just a few wrappers around other parts in iterum and calling their API.
