import { ArrayExpression } from "./visitors/ArrayExpression";
import { BinaryExpression } from "./visitors/BinaryExpression";
import { ExpressionStatement } from "./visitors/ExpressionStatement";
import { Identifier } from "./visitors/Identifier";
import { Literal } from "./visitors/Literal";
import { Program } from "./visitors/Program";
import { VariableDeclaration } from "./visitors/VariableDeclaration";
import { VariableDeclarator } from "./visitors/VariableDeclarator";

// TODO: uncomment visitors when they will have an implementation
export const VISITORS = {
  ArrayExpression,
  // ArrayPattern: () => notImplemented(),
  // ArrowFunctionExpression: () => notImplemented(),
  // AssignmentExpression: () => notImplemented(),
  // AssignmentPattern: () => notImplemented(),
  // AwaitExpression: () => notImplemented(),
  BinaryExpression,
  // BlockStatement: () => notImplemented(),
  // BreakStatement: () => notImplemented(),
  // CallExpression: () => notImplemented(),
  // CatchClause: () => notImplemented(),
  // Class: () => notImplemented(),
  // ClassBody: () => notImplemented(),
  // ClassDeclaration: () => notImplemented(),
  // ClassExpression: () => notImplemented(),
  // ComprehensionBlock: () => notImplemented(),
  // ComprehensionExpression: () => notImplemented(),
  // ComprehensionIf: () => notImplemented(),
  // ConditionalExpression: () => notImplemented(),
  // ContinueStatement: () => notImplemented(),
  // DebuggerStatement: () => notImplemented(),
  // Directive: () => notImplemented(),
  // DoWhileStatement: () => notImplemented(),
  // EmptyStatement: () => notImplemented(),
  // ExportAllDeclaration: () => notImplemented(),
  // ExportDefaultDeclaration: () => notImplemented(),
  // ExportNamedDeclaration: () => notImplemented(),
  // ExportSpecifier: () => notImplemented(),
  ExpressionStatement,
  // ForInStatement: () => notImplemented(),
  // ForOfStatement: () => notImplemented(),
  // ForStatement: () => notImplemented(),
  // Function: () => notImplemented(),
  // FunctionBody: () => notImplemented(),
  // FunctionDeclaration: () => notImplemented(),
  // FunctionExpression: () => notImplemented(),
  // GeneratorExpression: () => notImplemented(),
  // GraphExpression: () => notImplemented(),
  // GraphIndexExpression: () => notImplemented(),
  Identifier,
  // IfStatement: () => notImplemented(),
  // ImportDeclaration: () => notImplemented(),
  // ImportDefaultSpecifier: () => notImplemented(),
  // ImportNamespaceSpecifier: () => notImplemented(),
  // ImportSpecifier: () => notImplemented(),
  // LabeledStatement: () => notImplemented(),
  // LetExpression: () => notImplemented(),
  // LetStatement: () => notImplemented(),
  Literal,
  // LogicalExpression: () => notImplemented(),
  // MemberExpression: () => notImplemented(),
  // MetaProperty: () => notImplemented(),
  // MethodDefinition: () => notImplemented(),
  // ModuleSpecifier: () => notImplemented(),
  // NewExpression: () => notImplemented(),
  // ObjectExpression: () => notImplemented(),
  // ObjectPattern: () => notImplemented(),
  Program,
  // Property: () => notImplemented(),
  // PropertyPattern: () => notImplemented(),
  // RegExpLiteral: () => notImplemented(),
  // RestElement: () => notImplemented(),
  // ReturnStatement: () => notImplemented(),
  // SequenceExpression: () => notImplemented(),
  // SpreadElement: () => notImplemented(),
  // Super: () => notImplemented(),
  // SwitchCase: () => notImplemented(),
  // SwitchStatement: () => notImplemented(),
  // TaggedTemplateExpression: () => notImplemented(),
  // TemplateElement: () => notImplemented(),
  // TemplateLiteral: () => notImplemented(),
  // ThisExpression: () => notImplemented(),
  // ThrowStatement: () => notImplemented(),
  // TryStatement: () => notImplemented(),
  // UnaryExpression: () => notImplemented(),
  // UpdateExpression: () => notImplemented(),
  VariableDeclaration,
  VariableDeclarator,
  // WhileStatement: () => notImplemented(),
  // WithStatement: () => notImplemented(),
  // YieldExpression: () => notImplemented(),
};
